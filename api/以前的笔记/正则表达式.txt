	/* \w		字符[0-9a-zA-Z_]
	 * \s		空白[换行，tab，空格]
	 * \b		匹配一个单词的开头和结尾 \b3以3开头，3\b以3结尾
	 * i		不分大小写
	 * g		找到全部的
	 * m		找多行
	 * search	查找符合规则的字符并返回它的位置
	 * match	匹配符合规则的字符找不到返回null
	 * replace  替换符合规则的字符
	 * split	按照一个字符串或一个规则将字符串分成一个数组,第二个参数howmany
	 */


例子1：/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/

//关于 ? 
	[abc]?[123]	: 匹配?前面的[abc]里面的其中一个或0个
	\s?  :  匹配一个空格或者不匹配

//关于 (?:pattern|)
	[abc](?:\d*\.|)	: 匹配ac3232.或者ab

//关于[eE][+-]? 匹配e+  E- e- E+
	[eE][+-][12]? e+ e+1 E- E-2匹配前两个中的一个就可以了	

\uFEFF\xA0表示空格		[\u4e00-\u9fa5]表示中文

//例子：
	\(?0\d{2}[) -]?\d{8} ：
		\(? : 转义 			0个或者1个(
		0 : 0
		\d{2} : 2个数字
		[) -]? : 匹配0个或者1个) -这三个中的一个
		\d{8} : 8个数字
		
后向引用：
	/\b(\w+)\b\s+\1\b/g	:  这个表达式中的\b是指某单词中以什么开头或以什么结尾,这个\1就是前面()的分组
	我们也可以给这个分组取个名字，(?<name>exp)这个分组的名字就叫做name,\k<name>就可以得到这个分组了,也可以写成(?'name'exp)
	
//关于match 和 exec 的区别

	match: 字符串的方法, str.match(reg);
	exec: 正则表达式的方法,  reg.exec(str);
	
	它们的相同地方: 
		var str = "cat2 hat8";
		var reg = /(\w+)\d/;
		正则表达式后面没有g的情况下 结果都是: cat2 cat,都是先匹配第一个cat2(reg)，然后匹配第一组cat(\w+)
	exec对全局g无效,对match有效
	
	例如： 
		var str = "web2.0 .net3.0";
		var reg = /(\w+)(\d)\.(\d)/g;
		str.match(reg);  //web2.0 , .net3.0	(找到所有和正则表达式相匹配的字符串)
		reg.str(str);  //web2.0 , web , 2 , 0 (找到和正则表达式相匹配的第一个字符串，然后匹配第一个分组，第二个分组,....)
